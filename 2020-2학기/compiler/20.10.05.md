# 유한 오토마타

## 인식기(Recognizer) : automata

입력과 제어장치(규칙에의해 만들어지는)가 있고 스트링을 받아드리면 언어의 규칙에 맞게 만들어지는지의 여부를 boolean으로 출력

Definition : fa

기본 정의

     Q : finite, non-empty set of states.(반환 상태 집합)
     ∑ : finite input alphabet.(입력 심벌의 집합)
     δ : mapping function.(전이 함수)
     q0 ∈ Q : start(or initial) state.(시작상태)
     F ⊆ Q : set of final states.(종결상태)

### DFA(Deterministic Finite Automata)

- 결정적 유한 오토마타 : FA의 전이 함수가 δ(q,a)가 한 상태만을 갖는 경우에 DFA라 부르고 전이함수가 **δ(q,a)=p**로 표현한다.

A finite automaton M over an alphabet ∑ is a system
M = (Q, ∑, δ, q0, F)

정의

     Q : finite, non-empty set of states.(반환 상태 집합)
     ∑ : finite input alphabet.(입력 심벌의 집합)
     δ : δ(q,a)=p (전이 함수) // 이론적으로 표나 상태전이도로 나타낸다.프로그램에선 함수로 작성되어있는 집합이 되는듯 하다.
     q0 ∈ Q : start(or initial) state.(시작상태)
     F ⊆ Q : set of final states.(종결상태)

이전의 문법 정의와 비교

- G = (VN, VT, P, S)
- M = (Q, ∑, δ, q0, F)
- G 와 M의 구성이 똑같으며 F만 추가된 느낌

- ![1](./img/200928-1.PNG)

### NFA(Nondeterministic Finite Automata)

- 비결정적 유한 오토마타 : FA의 전이 함수가 δ(q,a)가 한 상태가아닌 여러가지 또는 공집합을 갖는 경우에 NFA라 부르고 전이함수가 **δ(q,a)={p1,p2,...}** 로 표현한다.

정의

     Q : finite, non-empty set of states.(반환 상태 집합)
     ∑ : finite input alphabet.(입력 심벌의 집합)
     δ : δ(q,a)={p1,p2,p3 ...} (전이 함수)
     q0 ∈ Q : start(or initial) state.(시작상태)
     F ⊆ Q : set of final states.(종결상태)

정의 식
![3](./img/201005-3.PNG)

예제
![4](./img/201005-4.PNG)

     δ(q0, 1001) = δ(q1, 001) || δ(q3, 001)
                 = δ(q1, 01) || δ(q2, 01) || ø
                 = δ(q1, 1) || δ(q2, 1) || δ(qf, 1)
                 = { q1,q3,qf }


## 상태 전이표()

유한 오토마타의 각 상태와 결과등을 표로 나타낸 것
![2](./img/201005-2.PNG)

## 상태 전이도(state transition diagram)

상태 전이도는 유한 오토마타의 각 상태를 노드로 나타내고, 전이 함수 δ(q, a) = p에 대해서 상태 q에서 p로 가고 레이블이 a인 지시선으로 나타낸다.
![1](./img/201005-1.PNG)

- 원 두겹 : 결과

## NFA를 DFA로 변환하기

하는 이유 : 일반적으로 NFA는 언어의 구조를 쉽게 표현할 수 있는 반면에 DFA보다 프로그램으로 구현하기 어려워서

NFA M = (Q, ∑, δ, q0, F)에 의해 인식되는 언어를 L이라 하면, L을 인식하는 DFA M\` = (Q\`, ∑\`, δ\`, q0\`, F\`)은 다음과 같이 구성한다.

1. Q\`(상태 집합) = 2^Q(Q의 부분집합)
   Q의 한 상태는 [q1,q2,q3,...]와 같이 리스트 처럼 표기
2. q0\` = [q0]
3. F\` = { q ∈ Q\` | q는 F의 상태들 중에 적어도 하나를 포함하는 상태 }
4. δ({q1,q2,...,qn}, a) = {p1,p2,...,pn} 이면, δ([q1,q2,...,qn], a) = [p1,p2,...,pn] 이다.

예제
![5](./img/201005-5.PNG)

1. 정의에 따라 상태, 이력 심벌, 함수, 시작심벌, 종결심벌 을 준비한다.
2. 함수에 맞는 모든 심벌을 반환하고 공집합으로 연결되지 않는 노드는 제외 한다.
3. 2개 이상의 상태를 가져왔을때 합집합으로 계산한다.

위와같이 정석적으로 계산시 상태가 2^N-1 개가 나와 상태의 수가 늘어날 수록 계산해야할 값이 많아진다. 모든 경우의 수를 계산하지 않는 방법은 다음과같다.

1. 시작 심벌로 함수를 실행한다.
2. 나온 결과 심벌이 노드(상태)가 있는 심벌이라면 지시선만 그리고 그렇지 않다면 노드를 생성한다.
3. 더이상 상태가 추가되지 않을때까지 진행한다.

위와 같이 dfa를 구하면 의미없는 종결 상태를 구하지 않고 dfa의 결과를 만들 수 있다.

## ε-전이를 갖는 NFA를 DFA로 변환하기 : ε-NFA

ε-NFA : 입력으로 ε이 올 수 있으며 ε을 보고 한 상태로부터 다음 상태로의 이동이 가능한 NFA

ε-NFA를 DFA로 바꾸기 위해서는 한상태에서 ε을 보고 갈 수 있는 상태들을 모두 구하는 작업이 필요하다.

이기능을 하는 함수를 **ε-CLOSURE** 라 한다.

![6](./img/201005-6.PNG)

> 약간 생성자처럼 ε에대한 설정을 먼저 처리후 진행하는듯 하다.

1. ε이 있는 노드는 자기자신포함 결과 심볼과 결과심볼에서 ε으로 연결된 결과 심볼까지 포함한 합집합이 대체된다.
2. 위의 예제상황이면 ε전이가 있는 1,3 에서 [1]은 [1,3,4] [3]은 [3,4] 로 정의되고 이에 맞춰 전이도를 만든다.

## DFA 상태수 최소화

전이표의 크기를 줄임으로 기억공간을 적게 차지하고 어휘분석 프로그램을 최적화하는데 도움을 준다.

동치관계를 합침으로 최소화한다.

![8](./img/201005-8.PNG)
![7](./img/201005-7.PNG)

1. 종결상태인지 아닌지로 동치류로 분할 후 네이밍
2. 분할된 동치류가 각 입력 심벌에 대해 어느 동치류로 전이 되는지 표로 나타낸다.
3. 동치류안에서 동치관계인 심벌끼리 또 나눈다.(동치관계란 같은 입력 심볼에의해 같은 결과를 가지는 동치류의 심벌을 말한다.)
4. 새로 나뉜 동치류에대해 다시 입력심볼에대해 어떻게 구분되는가를 표로 나타낸다.
5. 나뉘지 않을떄까지 2,3,4를 반복하고 더이상 나뉘지 않을때 동치류를 노드로 바꾸면 줄어든 상태의 수를 볼수 있다.

## 유한오토마타의 닫힘 성질

> 만약 L1,L2가 FAL이면, 다음도 역시 FAL이다.
> 1. L1 | L2
> 2. L1L2
> 3. L1^*