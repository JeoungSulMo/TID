## 어휘분석(Lexical analyzer) (2)

### 토큰 인식

시작전에 알아야할 것들

1. 토큰의 구조를 기술시 이용될 [정규표현](https://jeoungsulmo.github.io/posts/compiler/4)
2. 인식기를 설계하는데 편리한 [상태 전이도](https://jeoungsulmo.github.io/posts/compiler/5#%EC%83%81%ED%83%9C-%EC%A0%84%EC%9D%B4%EB%8F%84)와 [유한오토마타를 정규표현으로부터 얻는 것](https://jeoungsulmo.github.io/posts/compiler/6#%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D%EC%9D%84-%EC%9C%A0%ED%95%9C%EC%98%A4%ED%86%A0%EB%A7%88%ED%83%80%EB%A1%9C-%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0)
3. 토큰의 종류를 인식하는 인식기를 구성하기위해 먼저 문자의 종류를 다음과 같이 이해하고 진행한다.
   `letter` -> a | b | c |... | z | A | B | C | ... | Z
   `digit` -> 0 | 1 | 2 | ... | 9
   `special_char` -> + | - | \<sup><sup\*</sup></sup> | / | , | ; | ...
   편의상 `letter`를 l 로, `digit`은 d로 나타내기로 하자.

### C언어에서 변수 정수, 실수, 문자, 주석인식

C에서 정수 상수의 기준은 10진수, 8진수 16진수이다.

10진수는 0이 아닌 수 8진수는 0으로 16진수는 0x 또는 0X로 시작한다.

편의상 10진수를 non-digit `n`으로 8진수를 octal digit `o`로 16진수를 hexa digit `h`로 지정하겠다.

#### 명칭(변수) 인식

c언어 기준으로 명칭구조는 아래의 전이도와 같다.

![1](img/20201102-1.png)

##### 정규문법으로 표현

S -> lA | \_A  
 A -> lA | dA | \_A | ε

##### 최종적으로 정규표현식으로 표현 (A = aA+b ==> A = a<sup>\<sup><sup\*</sup></sup></sup>b)

S = (l + _)( l + d + _)<sup>\<sup><sup\*</sup></sup></sup>

#### 정수 및 상수 인식

##### 정수및 상수 인식 전이도

![2](img/20201102-2.png)

##### 정규문법으로 표현

S -> nA | 0B
A -> dA | ε
B -> oC | xD | XD | ε
C -> oC | ε  
D -> hE  
E -> hE | ε

##### 정규표현식으로 표현

E = hE + ε = h<sup>_</sup>ε = h<sup>_</sup> D = hE = hh<sup>_</sup> = h<sup>+</sup>  
C = oC + ε = o<sup>_</sup>
B = oC + xD + XD + ε = o<sup>+</sup> + (x + X)D = o<sup>+</sup> + (x + X)h<sup>+</sup> + ε
A = dA + ε = d<sup><sup\*</sup></sup>

S = nA + 0B = nd<sup>_</sup> + 0(o<sup>+</sup> + (x + X)h<sup>+</sup> + ε)
= nd<sup>_</sup> + 0 + 0o<sup>+</sup> + 0(x + X)h<sup>+</sup>

∴ S = nd<sup\*</sup> + 0 + 0o<sup>+</sup> + 0(x + X)h<sup>+</sup>

#### 실수 인식

##### 실수인식 전이도

![3](img/20201102-3.png)

##### 정규문법으로 표현

S -> dA  
D -> dE | +F | -G
A -> dA | .B  
E -> dE | ε
B -> dC  
F -> dE
C -> dC | eD | ε  
G -> dE

##### 정규표현식으로 표현

E = dE + ε = d*
F = dE = dd* = d<sup>+</sup>  
G = dE = dd* = d<sup>+</sup>
D = dE + '+'F + -G = dd* + '+'d<sup>+</sup> + -d +
= d<sup>+</sup> + '+'d<sup>+</sup> + -d<sup>+</sup> = (ε + '+' + -)d +

C = dC + eD + ε = dC+e(ε + '+' + -)d<sup>+</sup> + e
= d<sup>\*</sup>(e(ε + '+' + -) d<sup>+</sup> + ε)

B = dC=dd<sup\*</sup>(e(ε + '+' + -)d<sup>+</sup> +ε)
= d<sup>+</sup>+(e(ε + '+' + -) d<sup>+</sup> +ε)

A = dA + .B
= d<sup>\*</sup>.d+(e(ε + '+' + -)d<sup>+</sup> + ε)

S = dA
= dd<sup>\*</sup>. d<sup>+</sup>(e(ε + '+' + -) d<sup>+</sup> +ε)  
= d<sup>+</sup>.d<sup>+</sup>(e(ε + '+' + -) d<sup>+</sup> + ε)  
= d<sup>+</sup>.d<sup>+</sup>+ d<sup>+</sup>.d<sup>+</sup>e(ε + '+' + -) d<sup>+</sup>

#### 문자 인식

##### 문자인식 전이도

![4](img/20201102-4.png)

##### 정규문법으로 표현

S -> "A
A -> aA | "B | \C
B -> ε  
C -> cA

##### 정규표현식으로 표현

A = aA + " B + \C  
 = aA + " + \cA
= (a + \c)A + "
= (a + \c)<sup>\*</sup>"

S = " A
= "(a + \c)<sup>\*</sup>"

∴ S = "(a + \c)<sup>\*</sup>"

### 어휘분석기 구현

#### 주석 인식

##### 주석인식 전이도

![4](img/20201102-5.png)

##### 정규문법으로 표현

S -> /A
A -> *B
B -> aB | *C
C -> \*C | bB | /D
D -> ε

##### 정규표현식으로 표현

C = *C + bB + /D = \*<sup>\*</sup>(bB + /)
B = aB + \*\*<sup>\*</sup>(bB + /)
= aB + \*\*<sup>\*</sup>bB + \*\*<sup>\*</sup>/
= (a + \*\*<sup>\*</sup> b)B + \*\*<sup>\*</sup>/= (a + \*\*<sup>\*</sup>b)<sup>\*</sup>\*\*<sup>\*</sup>/
A = *B = _(a + \*\*<sup>\*</sup>b)\*\*<sup>\*</sup>_/
∴ S = /A = /\* (a + \*\*<sup>\*</sup>b)<sup>\*</sup>\*\*<sup>\*</sup>/

### 어휘분석기 구현

### 렉스
